// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PBNetStat.proto

#ifndef PROTOBUF_PBNetStat_2eproto__INCLUDED
#define PROTOBUF_PBNetStat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PBNetStat_2eproto();
void protobuf_AssignDesc_PBNetStat_2eproto();
void protobuf_ShutdownFile_PBNetStat_2eproto();

class NL_IpTableStat;
class NL_EthernetStat;
class NL_SwitchStat;
class NL_Message;

enum NL_EthernetStat_Status {
  NL_EthernetStat_Status_DOWN = 0,
  NL_EthernetStat_Status_UP = 1
};
bool NL_EthernetStat_Status_IsValid(int value);
const NL_EthernetStat_Status NL_EthernetStat_Status_Status_MIN = NL_EthernetStat_Status_DOWN;
const NL_EthernetStat_Status NL_EthernetStat_Status_Status_MAX = NL_EthernetStat_Status_UP;
const int NL_EthernetStat_Status_Status_ARRAYSIZE = NL_EthernetStat_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* NL_EthernetStat_Status_descriptor();
inline const ::std::string& NL_EthernetStat_Status_Name(NL_EthernetStat_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    NL_EthernetStat_Status_descriptor(), value);
}
inline bool NL_EthernetStat_Status_Parse(
    const ::std::string& name, NL_EthernetStat_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NL_EthernetStat_Status>(
    NL_EthernetStat_Status_descriptor(), name, value);
}
enum NL_SwitchStat_Status {
  NL_SwitchStat_Status_DOWN = 0,
  NL_SwitchStat_Status_UP = 1
};
bool NL_SwitchStat_Status_IsValid(int value);
const NL_SwitchStat_Status NL_SwitchStat_Status_Status_MIN = NL_SwitchStat_Status_DOWN;
const NL_SwitchStat_Status NL_SwitchStat_Status_Status_MAX = NL_SwitchStat_Status_UP;
const int NL_SwitchStat_Status_Status_ARRAYSIZE = NL_SwitchStat_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* NL_SwitchStat_Status_descriptor();
inline const ::std::string& NL_SwitchStat_Status_Name(NL_SwitchStat_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    NL_SwitchStat_Status_descriptor(), value);
}
inline bool NL_SwitchStat_Status_Parse(
    const ::std::string& name, NL_SwitchStat_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NL_SwitchStat_Status>(
    NL_SwitchStat_Status_descriptor(), name, value);
}
enum NL_SwitchStat_Duplex {
  NL_SwitchStat_Duplex_FULL = 0,
  NL_SwitchStat_Duplex_HALF = 1
};
bool NL_SwitchStat_Duplex_IsValid(int value);
const NL_SwitchStat_Duplex NL_SwitchStat_Duplex_Duplex_MIN = NL_SwitchStat_Duplex_FULL;
const NL_SwitchStat_Duplex NL_SwitchStat_Duplex_Duplex_MAX = NL_SwitchStat_Duplex_HALF;
const int NL_SwitchStat_Duplex_Duplex_ARRAYSIZE = NL_SwitchStat_Duplex_Duplex_MAX + 1;

const ::google::protobuf::EnumDescriptor* NL_SwitchStat_Duplex_descriptor();
inline const ::std::string& NL_SwitchStat_Duplex_Name(NL_SwitchStat_Duplex value) {
  return ::google::protobuf::internal::NameOfEnum(
    NL_SwitchStat_Duplex_descriptor(), value);
}
inline bool NL_SwitchStat_Duplex_Parse(
    const ::std::string& name, NL_SwitchStat_Duplex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NL_SwitchStat_Duplex>(
    NL_SwitchStat_Duplex_descriptor(), name, value);
}
enum NL_SwitchStat_Speed {
  NL_SwitchStat_Speed_MB10 = 0,
  NL_SwitchStat_Speed_MB100 = 1,
  NL_SwitchStat_Speed_MB1000 = 2
};
bool NL_SwitchStat_Speed_IsValid(int value);
const NL_SwitchStat_Speed NL_SwitchStat_Speed_Speed_MIN = NL_SwitchStat_Speed_MB10;
const NL_SwitchStat_Speed NL_SwitchStat_Speed_Speed_MAX = NL_SwitchStat_Speed_MB1000;
const int NL_SwitchStat_Speed_Speed_ARRAYSIZE = NL_SwitchStat_Speed_Speed_MAX + 1;

const ::google::protobuf::EnumDescriptor* NL_SwitchStat_Speed_descriptor();
inline const ::std::string& NL_SwitchStat_Speed_Name(NL_SwitchStat_Speed value) {
  return ::google::protobuf::internal::NameOfEnum(
    NL_SwitchStat_Speed_descriptor(), value);
}
inline bool NL_SwitchStat_Speed_Parse(
    const ::std::string& name, NL_SwitchStat_Speed* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NL_SwitchStat_Speed>(
    NL_SwitchStat_Speed_descriptor(), name, value);
}
enum NL_Message_Source {
  NL_Message_Source_IO = 0,
  NL_Message_Source_ADS = 1,
  NL_Message_Source_EFB = 2,
  NL_Message_Source_COMM = 3,
  NL_Message_Source_INVALID = -1
};
bool NL_Message_Source_IsValid(int value);
const NL_Message_Source NL_Message_Source_Source_MIN = NL_Message_Source_INVALID;
const NL_Message_Source NL_Message_Source_Source_MAX = NL_Message_Source_COMM;
const int NL_Message_Source_Source_ARRAYSIZE = NL_Message_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* NL_Message_Source_descriptor();
inline const ::std::string& NL_Message_Source_Name(NL_Message_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    NL_Message_Source_descriptor(), value);
}
inline bool NL_Message_Source_Parse(
    const ::std::string& name, NL_Message_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NL_Message_Source>(
    NL_Message_Source_descriptor(), name, value);
}
enum NL_Message_Command {
  NL_Message_Command_REGISTER = 0,
  NL_Message_Command_REGISTER_REQUEST = 1,
  NL_Message_Command_UPDATE = 2,
  NL_Message_Command_UPDATE_REQUEST = 3,
  NL_Message_Command_CLEAR = 4
};
bool NL_Message_Command_IsValid(int value);
const NL_Message_Command NL_Message_Command_Command_MIN = NL_Message_Command_REGISTER;
const NL_Message_Command NL_Message_Command_Command_MAX = NL_Message_Command_CLEAR;
const int NL_Message_Command_Command_ARRAYSIZE = NL_Message_Command_Command_MAX + 1;

const ::google::protobuf::EnumDescriptor* NL_Message_Command_descriptor();
inline const ::std::string& NL_Message_Command_Name(NL_Message_Command value) {
  return ::google::protobuf::internal::NameOfEnum(
    NL_Message_Command_descriptor(), value);
}
inline bool NL_Message_Command_Parse(
    const ::std::string& name, NL_Message_Command* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NL_Message_Command>(
    NL_Message_Command_descriptor(), name, value);
}
enum NL_Message_Network {
  NL_Message_Network_EDN = 0,
  NL_Message_Network_IDN = 1
};
bool NL_Message_Network_IsValid(int value);
const NL_Message_Network NL_Message_Network_Network_MIN = NL_Message_Network_EDN;
const NL_Message_Network NL_Message_Network_Network_MAX = NL_Message_Network_IDN;
const int NL_Message_Network_Network_ARRAYSIZE = NL_Message_Network_Network_MAX + 1;

const ::google::protobuf::EnumDescriptor* NL_Message_Network_descriptor();
inline const ::std::string& NL_Message_Network_Name(NL_Message_Network value) {
  return ::google::protobuf::internal::NameOfEnum(
    NL_Message_Network_descriptor(), value);
}
inline bool NL_Message_Network_Parse(
    const ::std::string& name, NL_Message_Network* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NL_Message_Network>(
    NL_Message_Network_descriptor(), name, value);
}
// ===================================================================

class NL_IpTableStat : public ::google::protobuf::Message {
 public:
  NL_IpTableStat();
  virtual ~NL_IpTableStat();

  NL_IpTableStat(const NL_IpTableStat& from);

  inline NL_IpTableStat& operator=(const NL_IpTableStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NL_IpTableStat& default_instance();

  void Swap(NL_IpTableStat* other);

  // implements Message ----------------------------------------------

  NL_IpTableStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NL_IpTableStat& from);
  void MergeFrom(const NL_IpTableStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ident = 1;
  inline bool has_ident() const;
  inline void clear_ident();
  static const int kIdentFieldNumber = 1;
  inline ::google::protobuf::uint32 ident() const;
  inline void set_ident(::google::protobuf::uint32 value);

  // required string chain = 2;
  inline bool has_chain() const;
  inline void clear_chain();
  static const int kChainFieldNumber = 2;
  inline const ::std::string& chain() const;
  inline void set_chain(const ::std::string& value);
  inline void set_chain(const char* value);
  inline void set_chain(const char* value, size_t size);
  inline ::std::string* mutable_chain();
  inline ::std::string* release_chain();
  inline void set_allocated_chain(::std::string* chain);

  // optional string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional uint64 byteCount = 4;
  inline bool has_bytecount() const;
  inline void clear_bytecount();
  static const int kByteCountFieldNumber = 4;
  inline ::google::protobuf::uint64 bytecount() const;
  inline void set_bytecount(::google::protobuf::uint64 value);

  // optional uint64 packetCount = 5;
  inline bool has_packetcount() const;
  inline void clear_packetcount();
  static const int kPacketCountFieldNumber = 5;
  inline ::google::protobuf::uint64 packetcount() const;
  inline void set_packetcount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:NL_IpTableStat)
 private:
  inline void set_has_ident();
  inline void clear_has_ident();
  inline void set_has_chain();
  inline void clear_has_chain();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_bytecount();
  inline void clear_has_bytecount();
  inline void set_has_packetcount();
  inline void clear_has_packetcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* chain_;
  ::std::string* desc_;
  ::google::protobuf::uint64 bytecount_;
  ::google::protobuf::uint64 packetcount_;
  ::google::protobuf::uint32 ident_;
  friend void  protobuf_AddDesc_PBNetStat_2eproto();
  friend void protobuf_AssignDesc_PBNetStat_2eproto();
  friend void protobuf_ShutdownFile_PBNetStat_2eproto();

  void InitAsDefaultInstance();
  static NL_IpTableStat* default_instance_;
};
// -------------------------------------------------------------------

class NL_EthernetStat : public ::google::protobuf::Message {
 public:
  NL_EthernetStat();
  virtual ~NL_EthernetStat();

  NL_EthernetStat(const NL_EthernetStat& from);

  inline NL_EthernetStat& operator=(const NL_EthernetStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NL_EthernetStat& default_instance();

  void Swap(NL_EthernetStat* other);

  // implements Message ----------------------------------------------

  NL_EthernetStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NL_EthernetStat& from);
  void MergeFrom(const NL_EthernetStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NL_EthernetStat_Status Status;
  static const Status DOWN = NL_EthernetStat_Status_DOWN;
  static const Status UP = NL_EthernetStat_Status_UP;
  static inline bool Status_IsValid(int value) {
    return NL_EthernetStat_Status_IsValid(value);
  }
  static const Status Status_MIN =
    NL_EthernetStat_Status_Status_MIN;
  static const Status Status_MAX =
    NL_EthernetStat_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    NL_EthernetStat_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return NL_EthernetStat_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return NL_EthernetStat_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return NL_EthernetStat_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 ident = 1;
  inline bool has_ident() const;
  inline void clear_ident();
  static const int kIdentFieldNumber = 1;
  inline ::google::protobuf::uint32 ident() const;
  inline void set_ident(::google::protobuf::uint32 value);

  // optional string interface = 2;
  inline bool has_interface() const;
  inline void clear_interface();
  static const int kInterfaceFieldNumber = 2;
  inline const ::std::string& interface() const;
  inline void set_interface(const ::std::string& value);
  inline void set_interface(const char* value);
  inline void set_interface(const char* value, size_t size);
  inline ::std::string* mutable_interface();
  inline ::std::string* release_interface();
  inline void set_allocated_interface(::std::string* interface);

  // optional string interfaceName = 3;
  inline bool has_interfacename() const;
  inline void clear_interfacename();
  static const int kInterfaceNameFieldNumber = 3;
  inline const ::std::string& interfacename() const;
  inline void set_interfacename(const ::std::string& value);
  inline void set_interfacename(const char* value);
  inline void set_interfacename(const char* value, size_t size);
  inline ::std::string* mutable_interfacename();
  inline ::std::string* release_interfacename();
  inline void set_allocated_interfacename(::std::string* interfacename);

  // optional uint64 rxGood = 4;
  inline bool has_rxgood() const;
  inline void clear_rxgood();
  static const int kRxGoodFieldNumber = 4;
  inline ::google::protobuf::uint64 rxgood() const;
  inline void set_rxgood(::google::protobuf::uint64 value);

  // optional uint64 rxErrors = 5;
  inline bool has_rxerrors() const;
  inline void clear_rxerrors();
  static const int kRxErrorsFieldNumber = 5;
  inline ::google::protobuf::uint64 rxerrors() const;
  inline void set_rxerrors(::google::protobuf::uint64 value);

  // optional uint64 rxDropped = 6;
  inline bool has_rxdropped() const;
  inline void clear_rxdropped();
  static const int kRxDroppedFieldNumber = 6;
  inline ::google::protobuf::uint64 rxdropped() const;
  inline void set_rxdropped(::google::protobuf::uint64 value);

  // optional uint64 rxOverruns = 7;
  inline bool has_rxoverruns() const;
  inline void clear_rxoverruns();
  static const int kRxOverrunsFieldNumber = 7;
  inline ::google::protobuf::uint64 rxoverruns() const;
  inline void set_rxoverruns(::google::protobuf::uint64 value);

  // optional uint64 rxFrame = 8;
  inline bool has_rxframe() const;
  inline void clear_rxframe();
  static const int kRxFrameFieldNumber = 8;
  inline ::google::protobuf::uint64 rxframe() const;
  inline void set_rxframe(::google::protobuf::uint64 value);

  // optional uint64 txGood = 9;
  inline bool has_txgood() const;
  inline void clear_txgood();
  static const int kTxGoodFieldNumber = 9;
  inline ::google::protobuf::uint64 txgood() const;
  inline void set_txgood(::google::protobuf::uint64 value);

  // optional uint64 txErrors = 10;
  inline bool has_txerrors() const;
  inline void clear_txerrors();
  static const int kTxErrorsFieldNumber = 10;
  inline ::google::protobuf::uint64 txerrors() const;
  inline void set_txerrors(::google::protobuf::uint64 value);

  // optional uint64 txDropped = 11;
  inline bool has_txdropped() const;
  inline void clear_txdropped();
  static const int kTxDroppedFieldNumber = 11;
  inline ::google::protobuf::uint64 txdropped() const;
  inline void set_txdropped(::google::protobuf::uint64 value);

  // optional uint64 txOverruns = 12;
  inline bool has_txoverruns() const;
  inline void clear_txoverruns();
  static const int kTxOverrunsFieldNumber = 12;
  inline ::google::protobuf::uint64 txoverruns() const;
  inline void set_txoverruns(::google::protobuf::uint64 value);

  // optional uint64 txCarrier = 13;
  inline bool has_txcarrier() const;
  inline void clear_txcarrier();
  static const int kTxCarrierFieldNumber = 13;
  inline ::google::protobuf::uint64 txcarrier() const;
  inline void set_txcarrier(::google::protobuf::uint64 value);

  // optional uint64 txCollisions = 14;
  inline bool has_txcollisions() const;
  inline void clear_txcollisions();
  static const int kTxCollisionsFieldNumber = 14;
  inline ::google::protobuf::uint64 txcollisions() const;
  inline void set_txcollisions(::google::protobuf::uint64 value);

  // optional .NL_EthernetStat.Status status = 15;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 15;
  inline ::NL_EthernetStat_Status status() const;
  inline void set_status(::NL_EthernetStat_Status value);

  // @@protoc_insertion_point(class_scope:NL_EthernetStat)
 private:
  inline void set_has_ident();
  inline void clear_has_ident();
  inline void set_has_interface();
  inline void clear_has_interface();
  inline void set_has_interfacename();
  inline void clear_has_interfacename();
  inline void set_has_rxgood();
  inline void clear_has_rxgood();
  inline void set_has_rxerrors();
  inline void clear_has_rxerrors();
  inline void set_has_rxdropped();
  inline void clear_has_rxdropped();
  inline void set_has_rxoverruns();
  inline void clear_has_rxoverruns();
  inline void set_has_rxframe();
  inline void clear_has_rxframe();
  inline void set_has_txgood();
  inline void clear_has_txgood();
  inline void set_has_txerrors();
  inline void clear_has_txerrors();
  inline void set_has_txdropped();
  inline void clear_has_txdropped();
  inline void set_has_txoverruns();
  inline void clear_has_txoverruns();
  inline void set_has_txcarrier();
  inline void clear_has_txcarrier();
  inline void set_has_txcollisions();
  inline void clear_has_txcollisions();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* interface_;
  ::std::string* interfacename_;
  ::google::protobuf::uint64 rxgood_;
  ::google::protobuf::uint64 rxerrors_;
  ::google::protobuf::uint64 rxdropped_;
  ::google::protobuf::uint64 rxoverruns_;
  ::google::protobuf::uint64 rxframe_;
  ::google::protobuf::uint32 ident_;
  int status_;
  ::google::protobuf::uint64 txgood_;
  ::google::protobuf::uint64 txerrors_;
  ::google::protobuf::uint64 txdropped_;
  ::google::protobuf::uint64 txoverruns_;
  ::google::protobuf::uint64 txcarrier_;
  ::google::protobuf::uint64 txcollisions_;
  friend void  protobuf_AddDesc_PBNetStat_2eproto();
  friend void protobuf_AssignDesc_PBNetStat_2eproto();
  friend void protobuf_ShutdownFile_PBNetStat_2eproto();

  void InitAsDefaultInstance();
  static NL_EthernetStat* default_instance_;
};
// -------------------------------------------------------------------

class NL_SwitchStat : public ::google::protobuf::Message {
 public:
  NL_SwitchStat();
  virtual ~NL_SwitchStat();

  NL_SwitchStat(const NL_SwitchStat& from);

  inline NL_SwitchStat& operator=(const NL_SwitchStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NL_SwitchStat& default_instance();

  void Swap(NL_SwitchStat* other);

  // implements Message ----------------------------------------------

  NL_SwitchStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NL_SwitchStat& from);
  void MergeFrom(const NL_SwitchStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NL_SwitchStat_Status Status;
  static const Status DOWN = NL_SwitchStat_Status_DOWN;
  static const Status UP = NL_SwitchStat_Status_UP;
  static inline bool Status_IsValid(int value) {
    return NL_SwitchStat_Status_IsValid(value);
  }
  static const Status Status_MIN =
    NL_SwitchStat_Status_Status_MIN;
  static const Status Status_MAX =
    NL_SwitchStat_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    NL_SwitchStat_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return NL_SwitchStat_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return NL_SwitchStat_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return NL_SwitchStat_Status_Parse(name, value);
  }

  typedef NL_SwitchStat_Duplex Duplex;
  static const Duplex FULL = NL_SwitchStat_Duplex_FULL;
  static const Duplex HALF = NL_SwitchStat_Duplex_HALF;
  static inline bool Duplex_IsValid(int value) {
    return NL_SwitchStat_Duplex_IsValid(value);
  }
  static const Duplex Duplex_MIN =
    NL_SwitchStat_Duplex_Duplex_MIN;
  static const Duplex Duplex_MAX =
    NL_SwitchStat_Duplex_Duplex_MAX;
  static const int Duplex_ARRAYSIZE =
    NL_SwitchStat_Duplex_Duplex_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Duplex_descriptor() {
    return NL_SwitchStat_Duplex_descriptor();
  }
  static inline const ::std::string& Duplex_Name(Duplex value) {
    return NL_SwitchStat_Duplex_Name(value);
  }
  static inline bool Duplex_Parse(const ::std::string& name,
      Duplex* value) {
    return NL_SwitchStat_Duplex_Parse(name, value);
  }

  typedef NL_SwitchStat_Speed Speed;
  static const Speed MB10 = NL_SwitchStat_Speed_MB10;
  static const Speed MB100 = NL_SwitchStat_Speed_MB100;
  static const Speed MB1000 = NL_SwitchStat_Speed_MB1000;
  static inline bool Speed_IsValid(int value) {
    return NL_SwitchStat_Speed_IsValid(value);
  }
  static const Speed Speed_MIN =
    NL_SwitchStat_Speed_Speed_MIN;
  static const Speed Speed_MAX =
    NL_SwitchStat_Speed_Speed_MAX;
  static const int Speed_ARRAYSIZE =
    NL_SwitchStat_Speed_Speed_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Speed_descriptor() {
    return NL_SwitchStat_Speed_descriptor();
  }
  static inline const ::std::string& Speed_Name(Speed value) {
    return NL_SwitchStat_Speed_Name(value);
  }
  static inline bool Speed_Parse(const ::std::string& name,
      Speed* value) {
    return NL_SwitchStat_Speed_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 ident = 1;
  inline bool has_ident() const;
  inline void clear_ident();
  static const int kIdentFieldNumber = 1;
  inline ::google::protobuf::uint32 ident() const;
  inline void set_ident(::google::protobuf::uint32 value);

  // optional .NL_SwitchStat.Status stat = 2;
  inline bool has_stat() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 2;
  inline ::NL_SwitchStat_Status stat() const;
  inline void set_stat(::NL_SwitchStat_Status value);

  // optional .NL_SwitchStat.Duplex dplx = 3;
  inline bool has_dplx() const;
  inline void clear_dplx();
  static const int kDplxFieldNumber = 3;
  inline ::NL_SwitchStat_Duplex dplx() const;
  inline void set_dplx(::NL_SwitchStat_Duplex value);

  // optional .NL_SwitchStat.Speed spd = 4;
  inline bool has_spd() const;
  inline void clear_spd();
  static const int kSpdFieldNumber = 4;
  inline ::NL_SwitchStat_Speed spd() const;
  inline void set_spd(::NL_SwitchStat_Speed value);

  // optional uint64 ingressbytes = 5;
  inline bool has_ingressbytes() const;
  inline void clear_ingressbytes();
  static const int kIngressbytesFieldNumber = 5;
  inline ::google::protobuf::uint64 ingressbytes() const;
  inline void set_ingressbytes(::google::protobuf::uint64 value);

  // optional uint64 ingressunicast = 6;
  inline bool has_ingressunicast() const;
  inline void clear_ingressunicast();
  static const int kIngressunicastFieldNumber = 6;
  inline ::google::protobuf::uint64 ingressunicast() const;
  inline void set_ingressunicast(::google::protobuf::uint64 value);

  // optional uint64 ingressbroadcast = 7;
  inline bool has_ingressbroadcast() const;
  inline void clear_ingressbroadcast();
  static const int kIngressbroadcastFieldNumber = 7;
  inline ::google::protobuf::uint64 ingressbroadcast() const;
  inline void set_ingressbroadcast(::google::protobuf::uint64 value);

  // optional uint64 ingressmulticast = 8;
  inline bool has_ingressmulticast() const;
  inline void clear_ingressmulticast();
  static const int kIngressmulticastFieldNumber = 8;
  inline ::google::protobuf::uint64 ingressmulticast() const;
  inline void set_ingressmulticast(::google::protobuf::uint64 value);

  // optional uint64 ingresspause = 9;
  inline bool has_ingresspause() const;
  inline void clear_ingresspause();
  static const int kIngresspauseFieldNumber = 9;
  inline ::google::protobuf::uint64 ingresspause() const;
  inline void set_ingresspause(::google::protobuf::uint64 value);

  // optional uint64 ingressundersize = 10;
  inline bool has_ingressundersize() const;
  inline void clear_ingressundersize();
  static const int kIngressundersizeFieldNumber = 10;
  inline ::google::protobuf::uint64 ingressundersize() const;
  inline void set_ingressundersize(::google::protobuf::uint64 value);

  // optional uint64 ingressfragments = 11;
  inline bool has_ingressfragments() const;
  inline void clear_ingressfragments();
  static const int kIngressfragmentsFieldNumber = 11;
  inline ::google::protobuf::uint64 ingressfragments() const;
  inline void set_ingressfragments(::google::protobuf::uint64 value);

  // optional uint64 ingressoversize = 12;
  inline bool has_ingressoversize() const;
  inline void clear_ingressoversize();
  static const int kIngressoversizeFieldNumber = 12;
  inline ::google::protobuf::uint64 ingressoversize() const;
  inline void set_ingressoversize(::google::protobuf::uint64 value);

  // optional uint64 ingressjabber = 13;
  inline bool has_ingressjabber() const;
  inline void clear_ingressjabber();
  static const int kIngressjabberFieldNumber = 13;
  inline ::google::protobuf::uint64 ingressjabber() const;
  inline void set_ingressjabber(::google::protobuf::uint64 value);

  // optional uint64 ingressrxerr = 14;
  inline bool has_ingressrxerr() const;
  inline void clear_ingressrxerr();
  static const int kIngressrxerrFieldNumber = 14;
  inline ::google::protobuf::uint64 ingressrxerr() const;
  inline void set_ingressrxerr(::google::protobuf::uint64 value);

  // optional uint64 ingressfcserr = 15;
  inline bool has_ingressfcserr() const;
  inline void clear_ingressfcserr();
  static const int kIngressfcserrFieldNumber = 15;
  inline ::google::protobuf::uint64 ingressfcserr() const;
  inline void set_ingressfcserr(::google::protobuf::uint64 value);

  // optional uint64 egressbytes = 16;
  inline bool has_egressbytes() const;
  inline void clear_egressbytes();
  static const int kEgressbytesFieldNumber = 16;
  inline ::google::protobuf::uint64 egressbytes() const;
  inline void set_egressbytes(::google::protobuf::uint64 value);

  // optional uint64 egressunicast = 17;
  inline bool has_egressunicast() const;
  inline void clear_egressunicast();
  static const int kEgressunicastFieldNumber = 17;
  inline ::google::protobuf::uint64 egressunicast() const;
  inline void set_egressunicast(::google::protobuf::uint64 value);

  // optional uint64 egressbroadcast = 18;
  inline bool has_egressbroadcast() const;
  inline void clear_egressbroadcast();
  static const int kEgressbroadcastFieldNumber = 18;
  inline ::google::protobuf::uint64 egressbroadcast() const;
  inline void set_egressbroadcast(::google::protobuf::uint64 value);

  // optional uint64 egressmulticast = 19;
  inline bool has_egressmulticast() const;
  inline void clear_egressmulticast();
  static const int kEgressmulticastFieldNumber = 19;
  inline ::google::protobuf::uint64 egressmulticast() const;
  inline void set_egressmulticast(::google::protobuf::uint64 value);

  // optional uint64 egresspause = 20;
  inline bool has_egresspause() const;
  inline void clear_egresspause();
  static const int kEgresspauseFieldNumber = 20;
  inline ::google::protobuf::uint64 egresspause() const;
  inline void set_egresspause(::google::protobuf::uint64 value);

  // optional uint64 egressexcessive = 21;
  inline bool has_egressexcessive() const;
  inline void clear_egressexcessive();
  static const int kEgressexcessiveFieldNumber = 21;
  inline ::google::protobuf::uint64 egressexcessive() const;
  inline void set_egressexcessive(::google::protobuf::uint64 value);

  // optional uint64 egresscollisions = 22;
  inline bool has_egresscollisions() const;
  inline void clear_egresscollisions();
  static const int kEgresscollisionsFieldNumber = 22;
  inline ::google::protobuf::uint64 egresscollisions() const;
  inline void set_egresscollisions(::google::protobuf::uint64 value);

  // optional uint64 egressother = 23;
  inline bool has_egressother() const;
  inline void clear_egressother();
  static const int kEgressotherFieldNumber = 23;
  inline ::google::protobuf::uint64 egressother() const;
  inline void set_egressother(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:NL_SwitchStat)
 private:
  inline void set_has_ident();
  inline void clear_has_ident();
  inline void set_has_stat();
  inline void clear_has_stat();
  inline void set_has_dplx();
  inline void clear_has_dplx();
  inline void set_has_spd();
  inline void clear_has_spd();
  inline void set_has_ingressbytes();
  inline void clear_has_ingressbytes();
  inline void set_has_ingressunicast();
  inline void clear_has_ingressunicast();
  inline void set_has_ingressbroadcast();
  inline void clear_has_ingressbroadcast();
  inline void set_has_ingressmulticast();
  inline void clear_has_ingressmulticast();
  inline void set_has_ingresspause();
  inline void clear_has_ingresspause();
  inline void set_has_ingressundersize();
  inline void clear_has_ingressundersize();
  inline void set_has_ingressfragments();
  inline void clear_has_ingressfragments();
  inline void set_has_ingressoversize();
  inline void clear_has_ingressoversize();
  inline void set_has_ingressjabber();
  inline void clear_has_ingressjabber();
  inline void set_has_ingressrxerr();
  inline void clear_has_ingressrxerr();
  inline void set_has_ingressfcserr();
  inline void clear_has_ingressfcserr();
  inline void set_has_egressbytes();
  inline void clear_has_egressbytes();
  inline void set_has_egressunicast();
  inline void clear_has_egressunicast();
  inline void set_has_egressbroadcast();
  inline void clear_has_egressbroadcast();
  inline void set_has_egressmulticast();
  inline void clear_has_egressmulticast();
  inline void set_has_egresspause();
  inline void clear_has_egresspause();
  inline void set_has_egressexcessive();
  inline void clear_has_egressexcessive();
  inline void set_has_egresscollisions();
  inline void clear_has_egresscollisions();
  inline void set_has_egressother();
  inline void clear_has_egressother();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ident_;
  int stat_;
  int dplx_;
  int spd_;
  ::google::protobuf::uint64 ingressbytes_;
  ::google::protobuf::uint64 ingressunicast_;
  ::google::protobuf::uint64 ingressbroadcast_;
  ::google::protobuf::uint64 ingressmulticast_;
  ::google::protobuf::uint64 ingresspause_;
  ::google::protobuf::uint64 ingressundersize_;
  ::google::protobuf::uint64 ingressfragments_;
  ::google::protobuf::uint64 ingressoversize_;
  ::google::protobuf::uint64 ingressjabber_;
  ::google::protobuf::uint64 ingressrxerr_;
  ::google::protobuf::uint64 ingressfcserr_;
  ::google::protobuf::uint64 egressbytes_;
  ::google::protobuf::uint64 egressunicast_;
  ::google::protobuf::uint64 egressbroadcast_;
  ::google::protobuf::uint64 egressmulticast_;
  ::google::protobuf::uint64 egresspause_;
  ::google::protobuf::uint64 egressexcessive_;
  ::google::protobuf::uint64 egresscollisions_;
  ::google::protobuf::uint64 egressother_;
  friend void  protobuf_AddDesc_PBNetStat_2eproto();
  friend void protobuf_AssignDesc_PBNetStat_2eproto();
  friend void protobuf_ShutdownFile_PBNetStat_2eproto();

  void InitAsDefaultInstance();
  static NL_SwitchStat* default_instance_;
};
// -------------------------------------------------------------------

class NL_Message : public ::google::protobuf::Message {
 public:
  NL_Message();
  virtual ~NL_Message();

  NL_Message(const NL_Message& from);

  inline NL_Message& operator=(const NL_Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NL_Message& default_instance();

  void Swap(NL_Message* other);

  // implements Message ----------------------------------------------

  NL_Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NL_Message& from);
  void MergeFrom(const NL_Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NL_Message_Source Source;
  static const Source IO = NL_Message_Source_IO;
  static const Source ADS = NL_Message_Source_ADS;
  static const Source EFB = NL_Message_Source_EFB;
  static const Source COMM = NL_Message_Source_COMM;
  static const Source INVALID = NL_Message_Source_INVALID;
  static inline bool Source_IsValid(int value) {
    return NL_Message_Source_IsValid(value);
  }
  static const Source Source_MIN =
    NL_Message_Source_Source_MIN;
  static const Source Source_MAX =
    NL_Message_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    NL_Message_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return NL_Message_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return NL_Message_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return NL_Message_Source_Parse(name, value);
  }

  typedef NL_Message_Command Command;
  static const Command REGISTER = NL_Message_Command_REGISTER;
  static const Command REGISTER_REQUEST = NL_Message_Command_REGISTER_REQUEST;
  static const Command UPDATE = NL_Message_Command_UPDATE;
  static const Command UPDATE_REQUEST = NL_Message_Command_UPDATE_REQUEST;
  static const Command CLEAR = NL_Message_Command_CLEAR;
  static inline bool Command_IsValid(int value) {
    return NL_Message_Command_IsValid(value);
  }
  static const Command Command_MIN =
    NL_Message_Command_Command_MIN;
  static const Command Command_MAX =
    NL_Message_Command_Command_MAX;
  static const int Command_ARRAYSIZE =
    NL_Message_Command_Command_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Command_descriptor() {
    return NL_Message_Command_descriptor();
  }
  static inline const ::std::string& Command_Name(Command value) {
    return NL_Message_Command_Name(value);
  }
  static inline bool Command_Parse(const ::std::string& name,
      Command* value) {
    return NL_Message_Command_Parse(name, value);
  }

  typedef NL_Message_Network Network;
  static const Network EDN = NL_Message_Network_EDN;
  static const Network IDN = NL_Message_Network_IDN;
  static inline bool Network_IsValid(int value) {
    return NL_Message_Network_IsValid(value);
  }
  static const Network Network_MIN =
    NL_Message_Network_Network_MIN;
  static const Network Network_MAX =
    NL_Message_Network_Network_MAX;
  static const int Network_ARRAYSIZE =
    NL_Message_Network_Network_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Network_descriptor() {
    return NL_Message_Network_descriptor();
  }
  static inline const ::std::string& Network_Name(Network value) {
    return NL_Message_Network_Name(value);
  }
  static inline bool Network_Parse(const ::std::string& name,
      Network* value) {
    return NL_Message_Network_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .NL_Message.Source source = 1 [default = INVALID];
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline ::NL_Message_Source source() const;
  inline void set_source(::NL_Message_Source value);

  // required .NL_Message.Command command = 2 [default = REGISTER];
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline ::NL_Message_Command command() const;
  inline void set_command(::NL_Message_Command value);

  // repeated .NL_IpTableStat ipStat = 3;
  inline int ipstat_size() const;
  inline void clear_ipstat();
  static const int kIpStatFieldNumber = 3;
  inline const ::NL_IpTableStat& ipstat(int index) const;
  inline ::NL_IpTableStat* mutable_ipstat(int index);
  inline ::NL_IpTableStat* add_ipstat();
  inline const ::google::protobuf::RepeatedPtrField< ::NL_IpTableStat >&
      ipstat() const;
  inline ::google::protobuf::RepeatedPtrField< ::NL_IpTableStat >*
      mutable_ipstat();

  // repeated .NL_SwitchStat switchStat = 4;
  inline int switchstat_size() const;
  inline void clear_switchstat();
  static const int kSwitchStatFieldNumber = 4;
  inline const ::NL_SwitchStat& switchstat(int index) const;
  inline ::NL_SwitchStat* mutable_switchstat(int index);
  inline ::NL_SwitchStat* add_switchstat();
  inline const ::google::protobuf::RepeatedPtrField< ::NL_SwitchStat >&
      switchstat() const;
  inline ::google::protobuf::RepeatedPtrField< ::NL_SwitchStat >*
      mutable_switchstat();

  // repeated .NL_EthernetStat ethernetStat = 5;
  inline int ethernetstat_size() const;
  inline void clear_ethernetstat();
  static const int kEthernetStatFieldNumber = 5;
  inline const ::NL_EthernetStat& ethernetstat(int index) const;
  inline ::NL_EthernetStat* mutable_ethernetstat(int index);
  inline ::NL_EthernetStat* add_ethernetstat();
  inline const ::google::protobuf::RepeatedPtrField< ::NL_EthernetStat >&
      ethernetstat() const;
  inline ::google::protobuf::RepeatedPtrField< ::NL_EthernetStat >*
      mutable_ethernetstat();

  // optional .NL_Message.Network switchStatNetwork = 6;
  inline bool has_switchstatnetwork() const;
  inline void clear_switchstatnetwork();
  static const int kSwitchStatNetworkFieldNumber = 6;
  inline ::NL_Message_Network switchstatnetwork() const;
  inline void set_switchstatnetwork(::NL_Message_Network value);

  // @@protoc_insertion_point(class_scope:NL_Message)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_switchstatnetwork();
  inline void clear_has_switchstatnetwork();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int source_;
  int command_;
  ::google::protobuf::RepeatedPtrField< ::NL_IpTableStat > ipstat_;
  ::google::protobuf::RepeatedPtrField< ::NL_SwitchStat > switchstat_;
  ::google::protobuf::RepeatedPtrField< ::NL_EthernetStat > ethernetstat_;
  int switchstatnetwork_;
  friend void  protobuf_AddDesc_PBNetStat_2eproto();
  friend void protobuf_AssignDesc_PBNetStat_2eproto();
  friend void protobuf_ShutdownFile_PBNetStat_2eproto();

  void InitAsDefaultInstance();
  static NL_Message* default_instance_;
};
// ===================================================================


// ===================================================================

// NL_IpTableStat

// required uint32 ident = 1;
inline bool NL_IpTableStat::has_ident() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NL_IpTableStat::set_has_ident() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NL_IpTableStat::clear_has_ident() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NL_IpTableStat::clear_ident() {
  ident_ = 0u;
  clear_has_ident();
}
inline ::google::protobuf::uint32 NL_IpTableStat::ident() const {
  // @@protoc_insertion_point(field_get:NL_IpTableStat.ident)
  return ident_;
}
inline void NL_IpTableStat::set_ident(::google::protobuf::uint32 value) {
  set_has_ident();
  ident_ = value;
  // @@protoc_insertion_point(field_set:NL_IpTableStat.ident)
}

// required string chain = 2;
inline bool NL_IpTableStat::has_chain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NL_IpTableStat::set_has_chain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NL_IpTableStat::clear_has_chain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NL_IpTableStat::clear_chain() {
  if (chain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chain_->clear();
  }
  clear_has_chain();
}
inline const ::std::string& NL_IpTableStat::chain() const {
  // @@protoc_insertion_point(field_get:NL_IpTableStat.chain)
  return *chain_;
}
inline void NL_IpTableStat::set_chain(const ::std::string& value) {
  set_has_chain();
  if (chain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chain_ = new ::std::string;
  }
  chain_->assign(value);
  // @@protoc_insertion_point(field_set:NL_IpTableStat.chain)
}
inline void NL_IpTableStat::set_chain(const char* value) {
  set_has_chain();
  if (chain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chain_ = new ::std::string;
  }
  chain_->assign(value);
  // @@protoc_insertion_point(field_set_char:NL_IpTableStat.chain)
}
inline void NL_IpTableStat::set_chain(const char* value, size_t size) {
  set_has_chain();
  if (chain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chain_ = new ::std::string;
  }
  chain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NL_IpTableStat.chain)
}
inline ::std::string* NL_IpTableStat::mutable_chain() {
  set_has_chain();
  if (chain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    chain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NL_IpTableStat.chain)
  return chain_;
}
inline ::std::string* NL_IpTableStat::release_chain() {
  clear_has_chain();
  if (chain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = chain_;
    chain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NL_IpTableStat::set_allocated_chain(::std::string* chain) {
  if (chain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete chain_;
  }
  if (chain) {
    set_has_chain();
    chain_ = chain;
  } else {
    clear_has_chain();
    chain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NL_IpTableStat.chain)
}

// optional string desc = 3;
inline bool NL_IpTableStat::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NL_IpTableStat::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NL_IpTableStat::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NL_IpTableStat::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& NL_IpTableStat::desc() const {
  // @@protoc_insertion_point(field_get:NL_IpTableStat.desc)
  return *desc_;
}
inline void NL_IpTableStat::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:NL_IpTableStat.desc)
}
inline void NL_IpTableStat::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:NL_IpTableStat.desc)
}
inline void NL_IpTableStat::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NL_IpTableStat.desc)
}
inline ::std::string* NL_IpTableStat::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NL_IpTableStat.desc)
  return desc_;
}
inline ::std::string* NL_IpTableStat::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NL_IpTableStat::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NL_IpTableStat.desc)
}

// optional uint64 byteCount = 4;
inline bool NL_IpTableStat::has_bytecount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NL_IpTableStat::set_has_bytecount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NL_IpTableStat::clear_has_bytecount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NL_IpTableStat::clear_bytecount() {
  bytecount_ = GOOGLE_ULONGLONG(0);
  clear_has_bytecount();
}
inline ::google::protobuf::uint64 NL_IpTableStat::bytecount() const {
  // @@protoc_insertion_point(field_get:NL_IpTableStat.byteCount)
  return bytecount_;
}
inline void NL_IpTableStat::set_bytecount(::google::protobuf::uint64 value) {
  set_has_bytecount();
  bytecount_ = value;
  // @@protoc_insertion_point(field_set:NL_IpTableStat.byteCount)
}

// optional uint64 packetCount = 5;
inline bool NL_IpTableStat::has_packetcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NL_IpTableStat::set_has_packetcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NL_IpTableStat::clear_has_packetcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NL_IpTableStat::clear_packetcount() {
  packetcount_ = GOOGLE_ULONGLONG(0);
  clear_has_packetcount();
}
inline ::google::protobuf::uint64 NL_IpTableStat::packetcount() const {
  // @@protoc_insertion_point(field_get:NL_IpTableStat.packetCount)
  return packetcount_;
}
inline void NL_IpTableStat::set_packetcount(::google::protobuf::uint64 value) {
  set_has_packetcount();
  packetcount_ = value;
  // @@protoc_insertion_point(field_set:NL_IpTableStat.packetCount)
}

// -------------------------------------------------------------------

// NL_EthernetStat

// required uint32 ident = 1;
inline bool NL_EthernetStat::has_ident() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NL_EthernetStat::set_has_ident() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NL_EthernetStat::clear_has_ident() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NL_EthernetStat::clear_ident() {
  ident_ = 0u;
  clear_has_ident();
}
inline ::google::protobuf::uint32 NL_EthernetStat::ident() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.ident)
  return ident_;
}
inline void NL_EthernetStat::set_ident(::google::protobuf::uint32 value) {
  set_has_ident();
  ident_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.ident)
}

// optional string interface = 2;
inline bool NL_EthernetStat::has_interface() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NL_EthernetStat::set_has_interface() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NL_EthernetStat::clear_has_interface() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NL_EthernetStat::clear_interface() {
  if (interface_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_->clear();
  }
  clear_has_interface();
}
inline const ::std::string& NL_EthernetStat::interface() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.interface)
  return *interface_;
}
inline void NL_EthernetStat::set_interface(const ::std::string& value) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_ = new ::std::string;
  }
  interface_->assign(value);
  // @@protoc_insertion_point(field_set:NL_EthernetStat.interface)
}
inline void NL_EthernetStat::set_interface(const char* value) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_ = new ::std::string;
  }
  interface_->assign(value);
  // @@protoc_insertion_point(field_set_char:NL_EthernetStat.interface)
}
inline void NL_EthernetStat::set_interface(const char* value, size_t size) {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_ = new ::std::string;
  }
  interface_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NL_EthernetStat.interface)
}
inline ::std::string* NL_EthernetStat::mutable_interface() {
  set_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interface_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NL_EthernetStat.interface)
  return interface_;
}
inline ::std::string* NL_EthernetStat::release_interface() {
  clear_has_interface();
  if (interface_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = interface_;
    interface_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NL_EthernetStat::set_allocated_interface(::std::string* interface) {
  if (interface_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete interface_;
  }
  if (interface) {
    set_has_interface();
    interface_ = interface;
  } else {
    clear_has_interface();
    interface_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NL_EthernetStat.interface)
}

// optional string interfaceName = 3;
inline bool NL_EthernetStat::has_interfacename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NL_EthernetStat::set_has_interfacename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NL_EthernetStat::clear_has_interfacename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NL_EthernetStat::clear_interfacename() {
  if (interfacename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interfacename_->clear();
  }
  clear_has_interfacename();
}
inline const ::std::string& NL_EthernetStat::interfacename() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.interfaceName)
  return *interfacename_;
}
inline void NL_EthernetStat::set_interfacename(const ::std::string& value) {
  set_has_interfacename();
  if (interfacename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interfacename_ = new ::std::string;
  }
  interfacename_->assign(value);
  // @@protoc_insertion_point(field_set:NL_EthernetStat.interfaceName)
}
inline void NL_EthernetStat::set_interfacename(const char* value) {
  set_has_interfacename();
  if (interfacename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interfacename_ = new ::std::string;
  }
  interfacename_->assign(value);
  // @@protoc_insertion_point(field_set_char:NL_EthernetStat.interfaceName)
}
inline void NL_EthernetStat::set_interfacename(const char* value, size_t size) {
  set_has_interfacename();
  if (interfacename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interfacename_ = new ::std::string;
  }
  interfacename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NL_EthernetStat.interfaceName)
}
inline ::std::string* NL_EthernetStat::mutable_interfacename() {
  set_has_interfacename();
  if (interfacename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    interfacename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NL_EthernetStat.interfaceName)
  return interfacename_;
}
inline ::std::string* NL_EthernetStat::release_interfacename() {
  clear_has_interfacename();
  if (interfacename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = interfacename_;
    interfacename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NL_EthernetStat::set_allocated_interfacename(::std::string* interfacename) {
  if (interfacename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete interfacename_;
  }
  if (interfacename) {
    set_has_interfacename();
    interfacename_ = interfacename;
  } else {
    clear_has_interfacename();
    interfacename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NL_EthernetStat.interfaceName)
}

// optional uint64 rxGood = 4;
inline bool NL_EthernetStat::has_rxgood() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NL_EthernetStat::set_has_rxgood() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NL_EthernetStat::clear_has_rxgood() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NL_EthernetStat::clear_rxgood() {
  rxgood_ = GOOGLE_ULONGLONG(0);
  clear_has_rxgood();
}
inline ::google::protobuf::uint64 NL_EthernetStat::rxgood() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.rxGood)
  return rxgood_;
}
inline void NL_EthernetStat::set_rxgood(::google::protobuf::uint64 value) {
  set_has_rxgood();
  rxgood_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.rxGood)
}

// optional uint64 rxErrors = 5;
inline bool NL_EthernetStat::has_rxerrors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NL_EthernetStat::set_has_rxerrors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NL_EthernetStat::clear_has_rxerrors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NL_EthernetStat::clear_rxerrors() {
  rxerrors_ = GOOGLE_ULONGLONG(0);
  clear_has_rxerrors();
}
inline ::google::protobuf::uint64 NL_EthernetStat::rxerrors() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.rxErrors)
  return rxerrors_;
}
inline void NL_EthernetStat::set_rxerrors(::google::protobuf::uint64 value) {
  set_has_rxerrors();
  rxerrors_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.rxErrors)
}

// optional uint64 rxDropped = 6;
inline bool NL_EthernetStat::has_rxdropped() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NL_EthernetStat::set_has_rxdropped() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NL_EthernetStat::clear_has_rxdropped() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NL_EthernetStat::clear_rxdropped() {
  rxdropped_ = GOOGLE_ULONGLONG(0);
  clear_has_rxdropped();
}
inline ::google::protobuf::uint64 NL_EthernetStat::rxdropped() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.rxDropped)
  return rxdropped_;
}
inline void NL_EthernetStat::set_rxdropped(::google::protobuf::uint64 value) {
  set_has_rxdropped();
  rxdropped_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.rxDropped)
}

// optional uint64 rxOverruns = 7;
inline bool NL_EthernetStat::has_rxoverruns() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NL_EthernetStat::set_has_rxoverruns() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NL_EthernetStat::clear_has_rxoverruns() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NL_EthernetStat::clear_rxoverruns() {
  rxoverruns_ = GOOGLE_ULONGLONG(0);
  clear_has_rxoverruns();
}
inline ::google::protobuf::uint64 NL_EthernetStat::rxoverruns() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.rxOverruns)
  return rxoverruns_;
}
inline void NL_EthernetStat::set_rxoverruns(::google::protobuf::uint64 value) {
  set_has_rxoverruns();
  rxoverruns_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.rxOverruns)
}

// optional uint64 rxFrame = 8;
inline bool NL_EthernetStat::has_rxframe() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NL_EthernetStat::set_has_rxframe() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NL_EthernetStat::clear_has_rxframe() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NL_EthernetStat::clear_rxframe() {
  rxframe_ = GOOGLE_ULONGLONG(0);
  clear_has_rxframe();
}
inline ::google::protobuf::uint64 NL_EthernetStat::rxframe() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.rxFrame)
  return rxframe_;
}
inline void NL_EthernetStat::set_rxframe(::google::protobuf::uint64 value) {
  set_has_rxframe();
  rxframe_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.rxFrame)
}

// optional uint64 txGood = 9;
inline bool NL_EthernetStat::has_txgood() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NL_EthernetStat::set_has_txgood() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NL_EthernetStat::clear_has_txgood() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NL_EthernetStat::clear_txgood() {
  txgood_ = GOOGLE_ULONGLONG(0);
  clear_has_txgood();
}
inline ::google::protobuf::uint64 NL_EthernetStat::txgood() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.txGood)
  return txgood_;
}
inline void NL_EthernetStat::set_txgood(::google::protobuf::uint64 value) {
  set_has_txgood();
  txgood_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.txGood)
}

// optional uint64 txErrors = 10;
inline bool NL_EthernetStat::has_txerrors() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NL_EthernetStat::set_has_txerrors() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NL_EthernetStat::clear_has_txerrors() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NL_EthernetStat::clear_txerrors() {
  txerrors_ = GOOGLE_ULONGLONG(0);
  clear_has_txerrors();
}
inline ::google::protobuf::uint64 NL_EthernetStat::txerrors() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.txErrors)
  return txerrors_;
}
inline void NL_EthernetStat::set_txerrors(::google::protobuf::uint64 value) {
  set_has_txerrors();
  txerrors_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.txErrors)
}

// optional uint64 txDropped = 11;
inline bool NL_EthernetStat::has_txdropped() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NL_EthernetStat::set_has_txdropped() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NL_EthernetStat::clear_has_txdropped() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NL_EthernetStat::clear_txdropped() {
  txdropped_ = GOOGLE_ULONGLONG(0);
  clear_has_txdropped();
}
inline ::google::protobuf::uint64 NL_EthernetStat::txdropped() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.txDropped)
  return txdropped_;
}
inline void NL_EthernetStat::set_txdropped(::google::protobuf::uint64 value) {
  set_has_txdropped();
  txdropped_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.txDropped)
}

// optional uint64 txOverruns = 12;
inline bool NL_EthernetStat::has_txoverruns() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NL_EthernetStat::set_has_txoverruns() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NL_EthernetStat::clear_has_txoverruns() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NL_EthernetStat::clear_txoverruns() {
  txoverruns_ = GOOGLE_ULONGLONG(0);
  clear_has_txoverruns();
}
inline ::google::protobuf::uint64 NL_EthernetStat::txoverruns() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.txOverruns)
  return txoverruns_;
}
inline void NL_EthernetStat::set_txoverruns(::google::protobuf::uint64 value) {
  set_has_txoverruns();
  txoverruns_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.txOverruns)
}

// optional uint64 txCarrier = 13;
inline bool NL_EthernetStat::has_txcarrier() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NL_EthernetStat::set_has_txcarrier() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NL_EthernetStat::clear_has_txcarrier() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NL_EthernetStat::clear_txcarrier() {
  txcarrier_ = GOOGLE_ULONGLONG(0);
  clear_has_txcarrier();
}
inline ::google::protobuf::uint64 NL_EthernetStat::txcarrier() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.txCarrier)
  return txcarrier_;
}
inline void NL_EthernetStat::set_txcarrier(::google::protobuf::uint64 value) {
  set_has_txcarrier();
  txcarrier_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.txCarrier)
}

// optional uint64 txCollisions = 14;
inline bool NL_EthernetStat::has_txcollisions() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NL_EthernetStat::set_has_txcollisions() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NL_EthernetStat::clear_has_txcollisions() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NL_EthernetStat::clear_txcollisions() {
  txcollisions_ = GOOGLE_ULONGLONG(0);
  clear_has_txcollisions();
}
inline ::google::protobuf::uint64 NL_EthernetStat::txcollisions() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.txCollisions)
  return txcollisions_;
}
inline void NL_EthernetStat::set_txcollisions(::google::protobuf::uint64 value) {
  set_has_txcollisions();
  txcollisions_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.txCollisions)
}

// optional .NL_EthernetStat.Status status = 15;
inline bool NL_EthernetStat::has_status() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NL_EthernetStat::set_has_status() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NL_EthernetStat::clear_has_status() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NL_EthernetStat::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::NL_EthernetStat_Status NL_EthernetStat::status() const {
  // @@protoc_insertion_point(field_get:NL_EthernetStat.status)
  return static_cast< ::NL_EthernetStat_Status >(status_);
}
inline void NL_EthernetStat::set_status(::NL_EthernetStat_Status value) {
  assert(::NL_EthernetStat_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:NL_EthernetStat.status)
}

// -------------------------------------------------------------------

// NL_SwitchStat

// required uint32 ident = 1;
inline bool NL_SwitchStat::has_ident() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NL_SwitchStat::set_has_ident() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NL_SwitchStat::clear_has_ident() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NL_SwitchStat::clear_ident() {
  ident_ = 0u;
  clear_has_ident();
}
inline ::google::protobuf::uint32 NL_SwitchStat::ident() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ident)
  return ident_;
}
inline void NL_SwitchStat::set_ident(::google::protobuf::uint32 value) {
  set_has_ident();
  ident_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ident)
}

// optional .NL_SwitchStat.Status stat = 2;
inline bool NL_SwitchStat::has_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NL_SwitchStat::set_has_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NL_SwitchStat::clear_has_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NL_SwitchStat::clear_stat() {
  stat_ = 0;
  clear_has_stat();
}
inline ::NL_SwitchStat_Status NL_SwitchStat::stat() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.stat)
  return static_cast< ::NL_SwitchStat_Status >(stat_);
}
inline void NL_SwitchStat::set_stat(::NL_SwitchStat_Status value) {
  assert(::NL_SwitchStat_Status_IsValid(value));
  set_has_stat();
  stat_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.stat)
}

// optional .NL_SwitchStat.Duplex dplx = 3;
inline bool NL_SwitchStat::has_dplx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NL_SwitchStat::set_has_dplx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NL_SwitchStat::clear_has_dplx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NL_SwitchStat::clear_dplx() {
  dplx_ = 0;
  clear_has_dplx();
}
inline ::NL_SwitchStat_Duplex NL_SwitchStat::dplx() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.dplx)
  return static_cast< ::NL_SwitchStat_Duplex >(dplx_);
}
inline void NL_SwitchStat::set_dplx(::NL_SwitchStat_Duplex value) {
  assert(::NL_SwitchStat_Duplex_IsValid(value));
  set_has_dplx();
  dplx_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.dplx)
}

// optional .NL_SwitchStat.Speed spd = 4;
inline bool NL_SwitchStat::has_spd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NL_SwitchStat::set_has_spd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NL_SwitchStat::clear_has_spd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NL_SwitchStat::clear_spd() {
  spd_ = 0;
  clear_has_spd();
}
inline ::NL_SwitchStat_Speed NL_SwitchStat::spd() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.spd)
  return static_cast< ::NL_SwitchStat_Speed >(spd_);
}
inline void NL_SwitchStat::set_spd(::NL_SwitchStat_Speed value) {
  assert(::NL_SwitchStat_Speed_IsValid(value));
  set_has_spd();
  spd_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.spd)
}

// optional uint64 ingressbytes = 5;
inline bool NL_SwitchStat::has_ingressbytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NL_SwitchStat::set_has_ingressbytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NL_SwitchStat::clear_has_ingressbytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NL_SwitchStat::clear_ingressbytes() {
  ingressbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressbytes();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressbytes() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressbytes)
  return ingressbytes_;
}
inline void NL_SwitchStat::set_ingressbytes(::google::protobuf::uint64 value) {
  set_has_ingressbytes();
  ingressbytes_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressbytes)
}

// optional uint64 ingressunicast = 6;
inline bool NL_SwitchStat::has_ingressunicast() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NL_SwitchStat::set_has_ingressunicast() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NL_SwitchStat::clear_has_ingressunicast() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NL_SwitchStat::clear_ingressunicast() {
  ingressunicast_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressunicast();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressunicast() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressunicast)
  return ingressunicast_;
}
inline void NL_SwitchStat::set_ingressunicast(::google::protobuf::uint64 value) {
  set_has_ingressunicast();
  ingressunicast_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressunicast)
}

// optional uint64 ingressbroadcast = 7;
inline bool NL_SwitchStat::has_ingressbroadcast() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NL_SwitchStat::set_has_ingressbroadcast() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NL_SwitchStat::clear_has_ingressbroadcast() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NL_SwitchStat::clear_ingressbroadcast() {
  ingressbroadcast_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressbroadcast();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressbroadcast() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressbroadcast)
  return ingressbroadcast_;
}
inline void NL_SwitchStat::set_ingressbroadcast(::google::protobuf::uint64 value) {
  set_has_ingressbroadcast();
  ingressbroadcast_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressbroadcast)
}

// optional uint64 ingressmulticast = 8;
inline bool NL_SwitchStat::has_ingressmulticast() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NL_SwitchStat::set_has_ingressmulticast() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NL_SwitchStat::clear_has_ingressmulticast() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NL_SwitchStat::clear_ingressmulticast() {
  ingressmulticast_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressmulticast();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressmulticast() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressmulticast)
  return ingressmulticast_;
}
inline void NL_SwitchStat::set_ingressmulticast(::google::protobuf::uint64 value) {
  set_has_ingressmulticast();
  ingressmulticast_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressmulticast)
}

// optional uint64 ingresspause = 9;
inline bool NL_SwitchStat::has_ingresspause() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NL_SwitchStat::set_has_ingresspause() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NL_SwitchStat::clear_has_ingresspause() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NL_SwitchStat::clear_ingresspause() {
  ingresspause_ = GOOGLE_ULONGLONG(0);
  clear_has_ingresspause();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingresspause() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingresspause)
  return ingresspause_;
}
inline void NL_SwitchStat::set_ingresspause(::google::protobuf::uint64 value) {
  set_has_ingresspause();
  ingresspause_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingresspause)
}

// optional uint64 ingressundersize = 10;
inline bool NL_SwitchStat::has_ingressundersize() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NL_SwitchStat::set_has_ingressundersize() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NL_SwitchStat::clear_has_ingressundersize() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NL_SwitchStat::clear_ingressundersize() {
  ingressundersize_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressundersize();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressundersize() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressundersize)
  return ingressundersize_;
}
inline void NL_SwitchStat::set_ingressundersize(::google::protobuf::uint64 value) {
  set_has_ingressundersize();
  ingressundersize_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressundersize)
}

// optional uint64 ingressfragments = 11;
inline bool NL_SwitchStat::has_ingressfragments() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NL_SwitchStat::set_has_ingressfragments() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NL_SwitchStat::clear_has_ingressfragments() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NL_SwitchStat::clear_ingressfragments() {
  ingressfragments_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressfragments();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressfragments() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressfragments)
  return ingressfragments_;
}
inline void NL_SwitchStat::set_ingressfragments(::google::protobuf::uint64 value) {
  set_has_ingressfragments();
  ingressfragments_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressfragments)
}

// optional uint64 ingressoversize = 12;
inline bool NL_SwitchStat::has_ingressoversize() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NL_SwitchStat::set_has_ingressoversize() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NL_SwitchStat::clear_has_ingressoversize() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NL_SwitchStat::clear_ingressoversize() {
  ingressoversize_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressoversize();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressoversize() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressoversize)
  return ingressoversize_;
}
inline void NL_SwitchStat::set_ingressoversize(::google::protobuf::uint64 value) {
  set_has_ingressoversize();
  ingressoversize_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressoversize)
}

// optional uint64 ingressjabber = 13;
inline bool NL_SwitchStat::has_ingressjabber() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NL_SwitchStat::set_has_ingressjabber() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NL_SwitchStat::clear_has_ingressjabber() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NL_SwitchStat::clear_ingressjabber() {
  ingressjabber_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressjabber();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressjabber() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressjabber)
  return ingressjabber_;
}
inline void NL_SwitchStat::set_ingressjabber(::google::protobuf::uint64 value) {
  set_has_ingressjabber();
  ingressjabber_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressjabber)
}

// optional uint64 ingressrxerr = 14;
inline bool NL_SwitchStat::has_ingressrxerr() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NL_SwitchStat::set_has_ingressrxerr() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NL_SwitchStat::clear_has_ingressrxerr() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NL_SwitchStat::clear_ingressrxerr() {
  ingressrxerr_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressrxerr();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressrxerr() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressrxerr)
  return ingressrxerr_;
}
inline void NL_SwitchStat::set_ingressrxerr(::google::protobuf::uint64 value) {
  set_has_ingressrxerr();
  ingressrxerr_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressrxerr)
}

// optional uint64 ingressfcserr = 15;
inline bool NL_SwitchStat::has_ingressfcserr() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NL_SwitchStat::set_has_ingressfcserr() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NL_SwitchStat::clear_has_ingressfcserr() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NL_SwitchStat::clear_ingressfcserr() {
  ingressfcserr_ = GOOGLE_ULONGLONG(0);
  clear_has_ingressfcserr();
}
inline ::google::protobuf::uint64 NL_SwitchStat::ingressfcserr() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.ingressfcserr)
  return ingressfcserr_;
}
inline void NL_SwitchStat::set_ingressfcserr(::google::protobuf::uint64 value) {
  set_has_ingressfcserr();
  ingressfcserr_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.ingressfcserr)
}

// optional uint64 egressbytes = 16;
inline bool NL_SwitchStat::has_egressbytes() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NL_SwitchStat::set_has_egressbytes() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NL_SwitchStat::clear_has_egressbytes() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NL_SwitchStat::clear_egressbytes() {
  egressbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_egressbytes();
}
inline ::google::protobuf::uint64 NL_SwitchStat::egressbytes() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.egressbytes)
  return egressbytes_;
}
inline void NL_SwitchStat::set_egressbytes(::google::protobuf::uint64 value) {
  set_has_egressbytes();
  egressbytes_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.egressbytes)
}

// optional uint64 egressunicast = 17;
inline bool NL_SwitchStat::has_egressunicast() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NL_SwitchStat::set_has_egressunicast() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NL_SwitchStat::clear_has_egressunicast() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NL_SwitchStat::clear_egressunicast() {
  egressunicast_ = GOOGLE_ULONGLONG(0);
  clear_has_egressunicast();
}
inline ::google::protobuf::uint64 NL_SwitchStat::egressunicast() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.egressunicast)
  return egressunicast_;
}
inline void NL_SwitchStat::set_egressunicast(::google::protobuf::uint64 value) {
  set_has_egressunicast();
  egressunicast_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.egressunicast)
}

// optional uint64 egressbroadcast = 18;
inline bool NL_SwitchStat::has_egressbroadcast() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NL_SwitchStat::set_has_egressbroadcast() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NL_SwitchStat::clear_has_egressbroadcast() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NL_SwitchStat::clear_egressbroadcast() {
  egressbroadcast_ = GOOGLE_ULONGLONG(0);
  clear_has_egressbroadcast();
}
inline ::google::protobuf::uint64 NL_SwitchStat::egressbroadcast() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.egressbroadcast)
  return egressbroadcast_;
}
inline void NL_SwitchStat::set_egressbroadcast(::google::protobuf::uint64 value) {
  set_has_egressbroadcast();
  egressbroadcast_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.egressbroadcast)
}

// optional uint64 egressmulticast = 19;
inline bool NL_SwitchStat::has_egressmulticast() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NL_SwitchStat::set_has_egressmulticast() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NL_SwitchStat::clear_has_egressmulticast() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NL_SwitchStat::clear_egressmulticast() {
  egressmulticast_ = GOOGLE_ULONGLONG(0);
  clear_has_egressmulticast();
}
inline ::google::protobuf::uint64 NL_SwitchStat::egressmulticast() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.egressmulticast)
  return egressmulticast_;
}
inline void NL_SwitchStat::set_egressmulticast(::google::protobuf::uint64 value) {
  set_has_egressmulticast();
  egressmulticast_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.egressmulticast)
}

// optional uint64 egresspause = 20;
inline bool NL_SwitchStat::has_egresspause() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NL_SwitchStat::set_has_egresspause() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NL_SwitchStat::clear_has_egresspause() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NL_SwitchStat::clear_egresspause() {
  egresspause_ = GOOGLE_ULONGLONG(0);
  clear_has_egresspause();
}
inline ::google::protobuf::uint64 NL_SwitchStat::egresspause() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.egresspause)
  return egresspause_;
}
inline void NL_SwitchStat::set_egresspause(::google::protobuf::uint64 value) {
  set_has_egresspause();
  egresspause_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.egresspause)
}

// optional uint64 egressexcessive = 21;
inline bool NL_SwitchStat::has_egressexcessive() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NL_SwitchStat::set_has_egressexcessive() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NL_SwitchStat::clear_has_egressexcessive() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NL_SwitchStat::clear_egressexcessive() {
  egressexcessive_ = GOOGLE_ULONGLONG(0);
  clear_has_egressexcessive();
}
inline ::google::protobuf::uint64 NL_SwitchStat::egressexcessive() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.egressexcessive)
  return egressexcessive_;
}
inline void NL_SwitchStat::set_egressexcessive(::google::protobuf::uint64 value) {
  set_has_egressexcessive();
  egressexcessive_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.egressexcessive)
}

// optional uint64 egresscollisions = 22;
inline bool NL_SwitchStat::has_egresscollisions() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NL_SwitchStat::set_has_egresscollisions() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NL_SwitchStat::clear_has_egresscollisions() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NL_SwitchStat::clear_egresscollisions() {
  egresscollisions_ = GOOGLE_ULONGLONG(0);
  clear_has_egresscollisions();
}
inline ::google::protobuf::uint64 NL_SwitchStat::egresscollisions() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.egresscollisions)
  return egresscollisions_;
}
inline void NL_SwitchStat::set_egresscollisions(::google::protobuf::uint64 value) {
  set_has_egresscollisions();
  egresscollisions_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.egresscollisions)
}

// optional uint64 egressother = 23;
inline bool NL_SwitchStat::has_egressother() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NL_SwitchStat::set_has_egressother() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NL_SwitchStat::clear_has_egressother() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NL_SwitchStat::clear_egressother() {
  egressother_ = GOOGLE_ULONGLONG(0);
  clear_has_egressother();
}
inline ::google::protobuf::uint64 NL_SwitchStat::egressother() const {
  // @@protoc_insertion_point(field_get:NL_SwitchStat.egressother)
  return egressother_;
}
inline void NL_SwitchStat::set_egressother(::google::protobuf::uint64 value) {
  set_has_egressother();
  egressother_ = value;
  // @@protoc_insertion_point(field_set:NL_SwitchStat.egressother)
}

// -------------------------------------------------------------------

// NL_Message

// required .NL_Message.Source source = 1 [default = INVALID];
inline bool NL_Message::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NL_Message::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NL_Message::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NL_Message::clear_source() {
  source_ = -1;
  clear_has_source();
}
inline ::NL_Message_Source NL_Message::source() const {
  // @@protoc_insertion_point(field_get:NL_Message.source)
  return static_cast< ::NL_Message_Source >(source_);
}
inline void NL_Message::set_source(::NL_Message_Source value) {
  assert(::NL_Message_Source_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:NL_Message.source)
}

// required .NL_Message.Command command = 2 [default = REGISTER];
inline bool NL_Message::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NL_Message::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NL_Message::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NL_Message::clear_command() {
  command_ = 0;
  clear_has_command();
}
inline ::NL_Message_Command NL_Message::command() const {
  // @@protoc_insertion_point(field_get:NL_Message.command)
  return static_cast< ::NL_Message_Command >(command_);
}
inline void NL_Message::set_command(::NL_Message_Command value) {
  assert(::NL_Message_Command_IsValid(value));
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:NL_Message.command)
}

// repeated .NL_IpTableStat ipStat = 3;
inline int NL_Message::ipstat_size() const {
  return ipstat_.size();
}
inline void NL_Message::clear_ipstat() {
  ipstat_.Clear();
}
inline const ::NL_IpTableStat& NL_Message::ipstat(int index) const {
  // @@protoc_insertion_point(field_get:NL_Message.ipStat)
  return ipstat_.Get(index);
}
inline ::NL_IpTableStat* NL_Message::mutable_ipstat(int index) {
  // @@protoc_insertion_point(field_mutable:NL_Message.ipStat)
  return ipstat_.Mutable(index);
}
inline ::NL_IpTableStat* NL_Message::add_ipstat() {
  // @@protoc_insertion_point(field_add:NL_Message.ipStat)
  return ipstat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NL_IpTableStat >&
NL_Message::ipstat() const {
  // @@protoc_insertion_point(field_list:NL_Message.ipStat)
  return ipstat_;
}
inline ::google::protobuf::RepeatedPtrField< ::NL_IpTableStat >*
NL_Message::mutable_ipstat() {
  // @@protoc_insertion_point(field_mutable_list:NL_Message.ipStat)
  return &ipstat_;
}

// repeated .NL_SwitchStat switchStat = 4;
inline int NL_Message::switchstat_size() const {
  return switchstat_.size();
}
inline void NL_Message::clear_switchstat() {
  switchstat_.Clear();
}
inline const ::NL_SwitchStat& NL_Message::switchstat(int index) const {
  // @@protoc_insertion_point(field_get:NL_Message.switchStat)
  return switchstat_.Get(index);
}
inline ::NL_SwitchStat* NL_Message::mutable_switchstat(int index) {
  // @@protoc_insertion_point(field_mutable:NL_Message.switchStat)
  return switchstat_.Mutable(index);
}
inline ::NL_SwitchStat* NL_Message::add_switchstat() {
  // @@protoc_insertion_point(field_add:NL_Message.switchStat)
  return switchstat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NL_SwitchStat >&
NL_Message::switchstat() const {
  // @@protoc_insertion_point(field_list:NL_Message.switchStat)
  return switchstat_;
}
inline ::google::protobuf::RepeatedPtrField< ::NL_SwitchStat >*
NL_Message::mutable_switchstat() {
  // @@protoc_insertion_point(field_mutable_list:NL_Message.switchStat)
  return &switchstat_;
}

// repeated .NL_EthernetStat ethernetStat = 5;
inline int NL_Message::ethernetstat_size() const {
  return ethernetstat_.size();
}
inline void NL_Message::clear_ethernetstat() {
  ethernetstat_.Clear();
}
inline const ::NL_EthernetStat& NL_Message::ethernetstat(int index) const {
  // @@protoc_insertion_point(field_get:NL_Message.ethernetStat)
  return ethernetstat_.Get(index);
}
inline ::NL_EthernetStat* NL_Message::mutable_ethernetstat(int index) {
  // @@protoc_insertion_point(field_mutable:NL_Message.ethernetStat)
  return ethernetstat_.Mutable(index);
}
inline ::NL_EthernetStat* NL_Message::add_ethernetstat() {
  // @@protoc_insertion_point(field_add:NL_Message.ethernetStat)
  return ethernetstat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NL_EthernetStat >&
NL_Message::ethernetstat() const {
  // @@protoc_insertion_point(field_list:NL_Message.ethernetStat)
  return ethernetstat_;
}
inline ::google::protobuf::RepeatedPtrField< ::NL_EthernetStat >*
NL_Message::mutable_ethernetstat() {
  // @@protoc_insertion_point(field_mutable_list:NL_Message.ethernetStat)
  return &ethernetstat_;
}

// optional .NL_Message.Network switchStatNetwork = 6;
inline bool NL_Message::has_switchstatnetwork() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NL_Message::set_has_switchstatnetwork() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NL_Message::clear_has_switchstatnetwork() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NL_Message::clear_switchstatnetwork() {
  switchstatnetwork_ = 0;
  clear_has_switchstatnetwork();
}
inline ::NL_Message_Network NL_Message::switchstatnetwork() const {
  // @@protoc_insertion_point(field_get:NL_Message.switchStatNetwork)
  return static_cast< ::NL_Message_Network >(switchstatnetwork_);
}
inline void NL_Message::set_switchstatnetwork(::NL_Message_Network value) {
  assert(::NL_Message_Network_IsValid(value));
  set_has_switchstatnetwork();
  switchstatnetwork_ = value;
  // @@protoc_insertion_point(field_set:NL_Message.switchStatNetwork)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NL_EthernetStat_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NL_EthernetStat_Status>() {
  return ::NL_EthernetStat_Status_descriptor();
}
template <> struct is_proto_enum< ::NL_SwitchStat_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NL_SwitchStat_Status>() {
  return ::NL_SwitchStat_Status_descriptor();
}
template <> struct is_proto_enum< ::NL_SwitchStat_Duplex> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NL_SwitchStat_Duplex>() {
  return ::NL_SwitchStat_Duplex_descriptor();
}
template <> struct is_proto_enum< ::NL_SwitchStat_Speed> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NL_SwitchStat_Speed>() {
  return ::NL_SwitchStat_Speed_descriptor();
}
template <> struct is_proto_enum< ::NL_Message_Source> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NL_Message_Source>() {
  return ::NL_Message_Source_descriptor();
}
template <> struct is_proto_enum< ::NL_Message_Command> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NL_Message_Command>() {
  return ::NL_Message_Command_descriptor();
}
template <> struct is_proto_enum< ::NL_Message_Network> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NL_Message_Network>() {
  return ::NL_Message_Network_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PBNetStat_2eproto__INCLUDED
